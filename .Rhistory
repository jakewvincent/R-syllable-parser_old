"EH0|EH1|EH2" = "ɛ",
"ER0|ER1|ER2" = "ɚ",
"EY0|EY1|EY2" = "eɪ",
"F" = "f",
"HH" = "h",
"IH0|IH1|IH2" = "ɪ",
"IY0|IY1|IY2" = "i",
"JH" = "ʤ",
"K" = "k",
"L" = "l",
"M" = "m",
"NG" = "ŋ",
"G" = "g",
"N" = "n",
"OW0|OW1|OW2" = "oʊ",
"OY0|OY1|OY2" = "ɔɪ",
"P" = "p",
"R" = "ɹ",
"SH" = "ʃ",
"S" = "s",
"TH" = "θ",
"T" = "t",
"UH0|UH1|UH2" = "ʊ",
"UW0|UW1|UW2" = "u",
"V" = "v",
"W" = "w",
"Y" = "j",
"ZH" = "ʒ",
"Z" = "z")
?missing
if (1 == 0) {
print("party")
}
print("party anyway")
if (1 == 1) {
print("party")
}
print("party anyway")
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/write_preinstalled_cmudict.R', echo=TRUE)
response <- "Y"
response == "y|Y"
response
c("A" = "B",
"B" = "C")
c("A" = "B",
"B" = "C") %>% class
?c
my.replacements <- c("AA0|AA1|AA2" = "ɑ",
"AE0|AE1|AE2" = "æ",
"AH0" = "ə",
"AH1|AH2" = "ʌ",
"AO0|AO1|AO2" = "ɔ",
"AW0|AW1|AW2" = "aʊ",
"AY0|AY1|AY2" = "aɪ",
"B" = "b",
"CH" = "ʧ",
"DH" = "ð",
"D" = "d",
"EH0|EH1|EH2" = "ɛ",
"ER0|ER1|ER2" = "ɚ",
"EY0|EY1|EY2" = "eɪ",
"F" = "f",
"HH" = "h",
"IH0|IH1|IH2" = "ɪ",
"IY0|IY1|IY2" = "i",
"JH" = "ʤ",
"K" = "k",
"L" = "l",
"M" = "m",
"NG" = "ŋ",
"G" = "g",
"N" = "n",
"OW0|OW1|OW2" = "oʊ",
"OY0|OY1|OY2" = "ɔɪ",
"P" = "p",
"R" = "ɹ",
"SH" = "ʃ",
"S" = "s",
"TH" = "θ",
"T" = "t",
"UH0|UH1|UH2" = "ʊ",
"UW0|UW1|UW2" = "u",
"V" = "v",
"W" = "w",
"Y" = "j",
"ZH" = "ʒ",
"Z" = "z")
user.replacements <- "my.replacements"
user.replacements
parse(user.replacements)
parse(eval(user.replacements))
eval(parse(text = user.replacements))
exists("user.replacements")
?ifelse
?Stop
?stop
test <- "no"
if (test == "no") {
stop("Stopped.")
}
message("The next thing is executed.")
test <- "no"
if (test == "no") {
stop("Stopped.")
} else {message("Nope")}
message("The next thing is executed.")
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/write_preinstalled_cmudict.R', echo=TRUE)
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/write_preinstalled_cmudict.R', echo=TRUE)
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/write_preinstalled_cmudict.R', echo=TRUE)
cmudict_dld
class_dld
class(cmudict_dld)
class(cmudict_dld) <- c(class(cmudict_dld), "unicode_df")
class(cmudict_dld)
cmudict_dld
cmudict_dld %>% as.data.frame
cmudict_dld %>% as.data.frame -> cmudict_dld_df
class(cmudict_dld_df)
class(cmudict_dld_df) <- c("data.frame", "unicode_df")
cmudict_dld_df
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/misc_functions.R', echo=TRUE)
cmudict_dld_df
print(cmudict_dld_df)
class(cmudict_dld_df)
class(cmudict_dld_df) <- c("unicode_df", "data.frame")
cmudict_dld_df
print.unicode_df(cmudict_dld_df)
cmudict_dld[,2:33]
cmudictipa
class(cmudictipa)
class(cmudict_dld_df)
print(cmudictipa)
cmudict_dld_df
cmudict_dld_df[2,2]
cmudict_dld_df[2,2] %>% class
cmudicti[a[2,2] %>% class
cmudictipa[2,2] %>% class
cmudictipa[2,2]
# this is print.default from base R with only two lines modified, see #old#
print.unicode_df <- function (x, ..., digits = NULL, quote = FALSE, right = TRUE, row.names = TRUE) {
n <- length(row.names(x))
if (length(x) == 0L) {
cat(sprintf(ngettext(n, "data frame with 0 columns and %d row",
"data frame with 0 columns and %d rows",
domain = "R-base"),
n),
"\n",
sep = "")
}
else if (n == 0L) {
print.default(names(x),
quote = FALSE)
cat(gettext("<0 rows> (or 0-length row.names)\n"))
}
else {
#old# m <- as.matrix(format.data.frame(x, digits = digits,
#old#     na.encode = FALSE))
m <- as.matrix(x)
if (!isTRUE(row.names))
dimnames(m)[[1L]] <- if (identical(row.names, FALSE))
rep.int("", n)
else row.names
print(m, ..., quote = quote, right = right)
}
invisible(x)
}
print(cmudict_dld_df)
cmudict_dld_df
cmudict_dld_df %>% head
# Get libraries
require(magrittr)
require(dplyr)
require(stringr)
require(tidyr)
require(dplyr)
require(RCurl)
require(readr)
cmudict_dld %>% head
cmudict_dld %>% head %>% class
cmudict_dld %>% head %>% as.data.frame()
cmudict_dld %>% head %>% as.data.frame() %>% class
cmudict_dld %>% head %>% as.data.frame() %>% class %<>% c("unicode_df", "data.frame")
cmudict_dld %>% head %>% as.data.frame() %>% class %<>% c("unicode_df", "data.frame")
cmudict_dld %>% as.data.frame -> cmudict_dld_df
cmudict_dld_df %>% class
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/misc_functions.R', echo=TRUE)
cmudict_dld_df
class(cmudict_dld_df)
class(cmudict_dld_df) <- "unicode_df"
class(cmudict_dld_df)
cmudict_dld_df %>% head
cmudictipa %>% head
cmudictipa %>% class
cmudict_dld
cmudict_dld %>% as.data.frame -> cmudict_dld_df
cmudict_dld_df
cmudict_dld_df %>% class
class(cmudict_dld_df) <- c("unicode_df", "data.frame")
class(cmudict_dld_df)
print(cmudict_dld_df)
cmudictarpa
cmudictarpa %>% class
cmudictarpa %>% rownames()
head(cmudict_dld)
"\u025B"
head(cmudict_dld)[2,2]
head(cmudict_dld)[2,2] %>% class
head(cmudict_dld)[2,2] %>% as.character()
head(cmudict_dld)[2,] %>% as.character()
head(cmudict_dld)[2,]
head(cmudict_dld)[2,1:33] -> testrow
testrow
testrow[2]
testrow[2] <- "\u025B"
testrow[7] <- "\u0259"
testrow[9]
testrow[9] <- "e\u026A"
testrow[10] <- "\u0283"
testrow
testrow[11] <- "\u0259"
testrow
class(testrow)
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/cmudict_downloader.R', echo=TRUE)
cmudict_raw %>% class
cmudict_raw %>% head
cmudict_raw %<>% subset(left(., 3) != ";;;")
# Replace spaces with commas, starting w/ double spaces
cmudict_raw %<>% str_replace_all("\\s\\s", ",")
cmudict_raw %<>% str_replace_all("\\s", ",")
# Find out which row is longest by counting commas
# Remove non-word characters from line beginnings
message("Removing non-word characters...")
cmudict_raw %<>% str_replace_all("(?<=^)[^\\w]", "")
longest <- 0
message("Finding longest word...")
for (n in 1:length(cmudict_raw)) {
str_count(cmudict_raw[n], ",") -> fields
if (fields > longest) {
longest <- fields
}
}
message("Storing version information...")
cmudict_raw <- c(latest_version, cmudict_raw)
cmudict_raw
message("Equalizing row lengths...")
for (n in 1:length(cmudict_raw)) {
# Get diff btw current row and longest row
to_add <- longest - str_count(cmudict_raw[n], ",")
# Add # of commas necessary to match longest row
cmudict_raw[n] <- paste(c(cmudict_raw[n], rep(",", to_add)), collapse = "")
}
message("Storing and reading as csv...")
write_lines(cmudict_raw,
path = "cmudict_raw.csv",
append = FALSE)
# Make a data.frame from cmudict_raw
cmudict_dld <- read_csv(file = "cmudict_raw.csv",
col_names = c("word", paste("segment", 1:longest, sep = "")),
col_types = cols(.default = col_character()))
class(cmudict_dld)
cmudict_dld %>% head
# Enrich dictionary with stress information
message("Extracting stress information...")
# Find max number of primary and secondary stresses
# Count the number of primary and secondary stresses in each word
prim_stress_counts <- str_count(apply(cmudict_dld[2:last_seg_col],
1,
paste,
collapse = ""),
"1")
sec_stress_counts <- str_count(apply(cmudict_dld[2:last_seg_col],
1,
paste,
collapse = ""),
"2")
# Get the highest number for each
max_prim_stress <- max(prim_stress_counts)
max_sec_stress <- max(sec_stress_counts)
# Add appropriate # of cols for each kind of stress
cmudict_dld[,paste("prstr",
1:max_prim_stress,
sep = "")] <- NA
cmudict_dld[,paste("secstr",
1:max_sec_stress,
sep = "")] <- NA
## Extract stress info into newly created columns
# Last segment column
last_seg_col <- longest + 1
# Last primary stress column
last_pstress_col <- last_seg_col + max_prim_stress
prim_stress_locs <- as.data.frame(
t(apply(cmudict_dld[,2:last_seg_col],
1, # Apply by row
function(x){
# Save the colnames of the segments that end in 1 (bear primary stress)
r_s <- colnames(cmudict_dld[,2:last_seg_col])[which(right(x, 1) == "1")]
# Concatenate these colnames w/ the num of NAs necessary to make the length 6
c(r_s,
rep(NA,
max_prim_stress-length(unlist(r_s))))
}
)
),
stringsAsFactors = FALSE
)
# Add primary stress locations to main cmudict df
cmudict_dld[,(last_seg_col+1):last_pstress_col] <- prim_stress_locs
# Create a df w/ secondary stress positions
sec_stress_locs <- as.data.frame(
t(apply(cmudict_dld[,2:last_seg_col],
1, # Apply by row
function(x){
# Save the colnames of the segments that end in 2 (bear secondary stress)
r_s <- colnames(cmudict_dld[,2:last_seg_col])[which(right(x, 1) == "2")]
# Concatenate these colnames w/ the num of NAs necessary to make the length 6
c(r_s,
rep(NA,
max_sec_stress-length(unlist(r_s))))
}
)
),
stringsAsFactors = FALSE
)
cmudict_dld[,(last_pstress_col+1):(last_pstress_col+max_sec_stress)] <- sec_stress_locs
cmudict_dld %>% class
cmudict_dld %>% head
"a\028A"
"a\u028A"
replacements <- c("AA0|AA1|AA2" = "\u0251", #\u0251 = ɑ
"AE0|AE1|AE2" = "\u00E6", #\u00E6 = æ
"AH0" = "\u0259", #\u0259 = ə
"AH1|AH2" = "\u028C", #\u028C = ʌ
"AO0|AO1|AO2" = "\u0254", #\u0254 = ɔ
"AW0|AW1|AW2" = "a\u028A", #\u028A = ʊ
"AY0|AY1|AY2" = "a\u026A", #\u026A  = ɪ
"B" = "b",
"CH" = "\u02A6", #\u02A6  = ʦ
"DH" = "\u00F0", #\u00F0  = ð
"D" = "d",
"EH0|EH1|EH2" = "\u025B", #\u025B  = ɛ
"ER0|ER1|ER2" = "\u025A", #\u025A  = ɚ
"EY0|EY1|EY2" = "e\u026A", #\u026A  = ɪ
"F" = "f",
"HH" = "h",
"IH0|IH1|IH2" = "\u026A", #\u026A  = ɪ
"IY0|IY1|IY2" = "i",
"JH" = "\u02A3", #\u02A3  = ʣ
"K" = "k",
"L" = "l",
"M" = "m",
"NG" = "\u014B", #\u014B  = ŋ
"G" = "g",
"N" = "n",
"OW0|OW1|OW2" = "o\u028A", #\u028A = ʊ
"OY0|OY1|OY2" = "\u0254\u026A", #\u0254 = ɔ, \u026A  = ɔɪ
"P" = "p",
"R" = "\u0279", #\u0279  = ɹ
"SH" = "\u0283", #\u0283  = ʃ
"S" = "s",
"TH" = "\u03B8", #\u03B8  = θ
"T" = "t",
"UH0|UH1|UH2" = "\u028A", #\u028A = ʊ
"UW0|UW1|UW2" = "u",
"V" = "v",
"W" = "w",
"Y" = "j",
"ZH" = "\u0292", #\u0292  = ʒ
"Z" = "z"
)
replacements
cmudict_dld[1:10,]
cmudict_dld[1:10,] -> cmudict_test
paste(cmudict_test[,2:33])
paste(cmudict_test[,2:33], sep="")
paste(cmudict_test[2,2:33], sep="")
paste(cmudict_test[2,2:33], collapse ="")
paste(cmudict_test[2,2:33], collapse = "")
cmudict_test
?paste
?mutate
apply(cmudict_test[2:last_seg_col,], 1, paste, collapse = "")
cmudict_test[2:last_seg_col,]
cmudict_test[,2:last_seg_col]
apply(cmudict_test[,2:last_seg_col], 1, paste, collapse="")
apply(cmudict_test[,"segment1":last_seg_col], 1, paste, collapse="")
apply(cmudict_test[,segment1:last_seg_col], 1, paste, collapse="")
apply(cmudict_test[,2:last_seg_col], 1, paste, collapse="")
?paste
?replace
replace(c(NA, NA, "EH1", "K", "K"), NA, "")
replace(c(NA, NA, "EH1", "K", "K"), c(NA, ""))
replace(NA, "")
replace(c(NA), 1, c("NA" = ""))
replace(c(NA, "b"), 1, c("NA" = ""))
# Create column for transcription
cmudict_test[,2:last_seg_col]
# Create column for transcription
cmudict_test[2,2:last_seg_col]
which(cmudict_test[2,2:last_seg_col]) = NA
which(cmudict_test[2,2:last_seg_col]) == NA
which(cmudict_test[2,2:last_seg_col] == NA)
cmudict_test[2,2:last_seg_col]
which(cmudict_test[2,2:last_seg_col] == "NA")
which(cmudict_test[2,10:last_seg_col] == "NA")
cmudict_test[2,10:last_seg_col]
cmudict_test[2,17]
cmudict_test[2,17] == NA
cmudict_test[2,17]
cmudict_test[2,17] == "NA"
cmudict_test[2,17] == "NA"
as.character(cmudict_test[2,17]) == "NA"
as.character(cmudict_test[2,17]) == NA
is.na(cmudict_test[2,17])
which(is.na(cmudict_test[2,10:last_seg_col]))
# Create column for transcription
replace(cmudict_test[2,2:last_seg_col], which(is.na(cmudict_test[2,2:last_seg_col]), c(NA = ""))
# Let user know formatting is done
message("Formatting complete.")
}
# Create column for transcription
replace(cmudict_test[2,2:last_seg_col], which(is.na(cmudict_test[2,2:last_seg_col])), c(NA = ""))
# Create column for transcription
replace(cmudict_test[2,2:last_seg_col], which(is.na(cmudict_test[2,2:last_seg_col])), c("NA" = ""))
# Create column for transcription
replace(cmudict_test[2,2:last_seg_col], which(is.na(cmudict_test[2,2:last_seg_col])), c("NA" = "")) -> testrow
testrow
testrow[18]
paste(replace(cmudict_test[2,2:last_seg_col], which(is.na(cmudict_test[2,2:last_seg_col])), c("NA" = "")) -> testrow, collapse="")
?pbapply
require(pbapply)
?pbapply
pbapply(
# The cmudict w/ the NAs in each row replaced by an empty string
replace(cmudict_test[,2:last_seg_col],
which(is.na(cmudict_test[,2:last_seg_col])),
c("NA" = "")),
# By row
1,
# Function to apply
paste,
# Arg for paste
collapse = ""
)
apply(
# The cmudict w/ the NAs in each row replaced by an empty string
replace(cmudict_test[,2:last_seg_col],
which(is.na(cmudict_test[,2:last_seg_col])),
c("NA" = "")),
# By row
1,
# Function to apply
paste,
# Arg for paste
collapse = ""
)
apply(
# The cmudict w/ the NAs in each row replaced by an empty string
cmudict_test,
# By row
1,
# Function to apply
function(x){
replace(x[,2:last_seg_col],
which(is.na(x[,2:last_seg_col])),
c("NA" = ""))
paste(x, collapse = "")
}
)
paste(
replace(cmudict_test[,2:last_seg_col],
which(is.na(cmudict_test[,2:last_seg_col])),
c("NA" = "")),
collapse = ""
)
paste(
replace(cmudict_test[2,2:last_seg_col],
which(is.na(cmudict_test[2,2:last_seg_col])),
c("NA" = "")),
collapse = ""
)
?apply
paste(
replace(cmudict_test[,2:last_seg_col],
which(is.na(cmudict_test[,2:last_seg_col])),
c("NA" = "")),
collapse = ""
)
replace(cmudict_test[,2:last_seg_col],
+               which(is.na(cmudict_test[,2:last_seg_col])),
+               c("NA" = ""))
replace(cmudict_test[,2:last_seg_col],
which(is.na(cmudict_test[,2:last_seg_col])),
c("NA" = ""))
pbapply(
# The cmudict w/ the NAs in each row replaced by an empty string
cmudict_test[,2:last_seg_col],
# By row
1,
# Function to apply
function(x){
paste(
replace(x,
which(is.na(x)),
c("NA" = "")),
collapse = ""
)
}
)
colnames(cmudictipa)
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/write_preinstalled_cmudict.R', echo=TRUE)
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/master.R', echo=TRUE)
cmudict_preinstalled %>% head
