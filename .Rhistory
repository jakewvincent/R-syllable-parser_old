require(tidyr)
require(dplyr)
require(RCurl)
require(readr)
# Import misc. functions
source(file = "misc_functions.R")
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/cmudict_downloader.R', echo=TRUE)
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/cmudict_formatter.R', encoding = 'UTF-8', echo=TRUE)
source.utf8(f = cmudict_formatter.R)
source.utf8(f = "cmudict_formatter.R")
warnings()
cmudict_dld %>% head
cmudict_dld[2,1]
cmudict_dld[2,2]
require(magrittr)
require(dplyr)
require(stringr)
require(tidyr)
require(dplyr)
require(RCurl)
require(readr)
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/misc_functions.R', echo=TRUE)
cmudictipa %>% class
cmudict_dld %>% class
cmudict_dld[1:20,]
cmudict_dld[1:20,] -> cmudict_test
cmudict_test
cmudict_test[2:33]
str_replace_all(cmudict_test[2:33], c("EH1" = "ɛ", "EH2" = "ɛ"))
str_replace_all(cmudict_test[1,2], c("EH1" = "ɛ", "EH2" = "ɛ"))
cmudict_test[1,2]
str_replace_all(cmudict_test[1,2], c("EH2"= "ɛ"))
str_replace_all(cmudict_test[1,2], c("EH2"= "ɛ")) -> cmudict_test[1,2]
cmudict_test
?str_replace_all
str_replace(cmudict_test[2:33], c("EH1" = "ɛ", "EH2" = "ɛ"))
cmudict_test[2:33]
cmudict_test[2:33] %>% as.vector
cmudict_test[2] %>% as.vector
cmudict_test[2] %>% as.vector %>% str_replace_all(c("EH1" = "ɛ", "EH2" = "ɛ"))
cmudict_test[2]
cmudict_test[2] %>% as.vector()
cmudict_test[2] %>% as.vector(.)
cmudict_test[2] %>% pull
cmudict_test[2]
cmudict_test[2:4]
cmudict_test[2:4] %>% pull
cmudict_test[2] %>% pull
cmudict_test[2] %>% pull %>% str_replace_all(c("K", "#"))
cmudict_test[2] %>% pull %>% str_replace_all(c("K" = "#"))
cmudict_test[2] %>% pull %>% str_replace_all(c("K" = "#")) -> cmudict_test[2]
cmudict_test[2]
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/cmudict_downloader.R', echo=TRUE)
?require
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/cmudict_downloader.R', echo=TRUE)
?read_lines
?show
?show_progress
?read_lines
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/cmudict_downloader.R', echo=TRUE)
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/cmudict_formatter.R', encoding = 'UTF-8', echo=TRUE)
source.utf8(f = "cmudict_formatter.R")
cmudict_dld %>% head()
?ifelse
cars
apply(cars, MARGIN = 1, mean)
apply(cars, MARGIN = 1, mean) -> cars$mean
cars
NULL -> cars$mean
cars
cars$speed
apply(cars, MARGIN = 1, ifelse(cars$speed < 10, "A", "B"))
apply(cars, MARGIN = 1, ifelse, cars$speed < 10, "A", "B")
apply(cars, MARGIN = 1, ifelse, test = cars$speed < 10, yes = "A", no = "B")
lapply(cars, FUN = mean)
lapply(cars, MARGIN = 1, FUN = mean)
mapply(cars, MARGIN = 1, FUN = mean)
apply(cars, MARGIN = 1, FUN = mean)
?apply
apply(cars, MARGIN = 1, FUN = function(x){ifelse(test = cars(x)[1] < 10, yes = "A", no = "B")})
apply(cars, MARGIN = 1, FUN = function(x){ifelse(test = cars[x][1] < 10, yes = "A", no = "B")})
apply(cars, MARGIN = 1, FUN = function(x){ifelse(test = cars[x] < 10, yes = "A", no = "B")})
apply(cars, MARGIN = 1, FUN = function(x){ifelse(test = x < 10, yes = "A", no = "B")})
cars
cars %>% class
apply(cars, MARGIN = 1, FUN = function(x){ifelse(test = x < 10, yes = "A", no = "B")}) %>% class
apply(cars, MARGIN = 1, FUN = function(x){ifelse(test = x < 10, yes = "A", no = "B")}) %>% as.data.frame
apply(cars, MARGIN = 1, FUN = function(x){ifelse(test = x < 10, yes = "A", no = "B")})
apply(cars, MARGIN = 1, FUN = function(x){ifelse(test = x < 10, yes = "A", no = "B")}) -> cars
cars
apply(cars, MARGIN = c(1, 2), FUN = function(x){ifelse(test = x < 10, yes = "A", no = "B")})
apply(cars, MARGIN = 1, FUN = function(x){ifelse(test = x < 10, yes = "A", no = "B")})
cars
rm(cars)
cars
apply(cars, MARGIN = c(1, 2), FUN = function(x){ifelse(test = x < 10, yes = "A", no = "B")})
apply(cars, MARGIN = c(1, 2), FUN = function(x){ifelse(test = x < 10, yes = "A", no = "B")}) -> cars
cars
cars %>% as.data.frame
cmudict_test
cmudict_dld[2:@0]
cmudict_dld[2:20]
cmudict_dld[2:20,]
cmudict_dld[2:20,] -> cmudict_test
cmudict_test
?mutate
cmudict_test
cmudict_dld
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/cmudict_downloader.R', echo=TRUE)
# If dict has been successfully downloaded, do some cleanup
if (exists("cmudict_raw") == TRUE) {
message("Formatting dictionary...")
# Remove comment lines
message("Removing comments...")
cmudict_raw %<>% subset(left(., 3) != ";;;")
# Replace spaces with commas, starting w/ double spaces
cmudict_raw %<>% str_replace_all("\\s\\s", ",")
cmudict_raw %<>% str_replace_all("\\s", ",")
# Find out which row is longest by counting commas
# Remove non-word characters from line beginnings
message("Removing non-word characters...")
cmudict_raw %<>% str_replace_all("(?<=^)[^\\w]", "")
longest <- 0
message("Finding longest word...")
for (n in 1:length(cmudict_raw)) {
str_count(cmudict_raw[n], ",") -> fields
if (fields > longest) {
longest <- fields
}
}
# Add version to cmudict_raw
message("Storing version information...")
cmudict_raw <- c(latest_version, cmudict_raw)
# Equalize # of fields (add fields to rows that are shorter than row w/ the highest # of fields)
message("Equalizing row lengths...")
for (n in 1:length(cmudict_raw)) {
# Get diff btw current row and longest row
to_add <- longest - str_count(cmudict_raw[n], ",")
# Add # of commas necessary to match longest row
cmudict_raw[n] <- paste(c(cmudict_raw[n], rep(",", to_add)), collapse = "")
}
# Save as csv
message("Storing and reading as csv...")
write_lines(cmudict_raw,
path = "cmudict_raw.csv",
append = FALSE)
# Make a data.frame from cmudict_raw
cmudict_dld <- read_csv(file = "cmudict_raw.csv",
col_names = c("word", paste("segment", 1:longest, sep = "")),
col_types = cols(.default = col_character()))
cmudict_dld
# If dict has been successfully downloaded, do some cleanup
if (exists("cmudict_raw") == TRUE) {
message("Formatting dictionary...")
# Remove comment lines
message("Removing comments...")
cmudict_raw %<>% subset(left(., 3) != ";;;")
# Replace spaces with commas, starting w/ double spaces
cmudict_raw %<>% str_replace_all("\\s\\s", ",")
cmudict_raw %<>% str_replace_all("\\s", ",")
# Find out which row is longest by counting commas
# Remove non-word characters from line beginnings
message("Removing non-word characters...")
cmudict_raw %<>% str_replace_all("(?<=^)[^\\w]", "")
longest <- 0
message("Finding longest word...")
for (n in 1:length(cmudict_raw)) {
str_count(cmudict_raw[n], ",") -> fields
if (fields > longest) {
longest <- fields
}
}
# Add version to cmudict_raw
message("Storing version information...")
cmudict_raw <- c(latest_version, cmudict_raw)
# Equalize # of fields (add fields to rows that are shorter than row w/ the highest # of fields)
message("Equalizing row lengths...")
for (n in 1:length(cmudict_raw)) {
# Get diff btw current row and longest row
to_add <- longest - str_count(cmudict_raw[n], ",")
# Add # of commas necessary to match longest row
cmudict_raw[n] <- paste(c(cmudict_raw[n], rep(",", to_add)), collapse = "")
}
# Save as csv
message("Storing and reading as csv...")
write_lines(cmudict_raw,
path = "cmudict_raw.csv",
append = FALSE)
# Make a data.frame from cmudict_raw
cmudict_dld <- read_csv(file = "cmudict_raw.csv",
col_names = c("word", paste("segment", 1:longest, sep = "")),
col_types = cols(.default = col_character()))}
cmudict_dld
cmudict_dld[2:20,] -> cmudict_test
cmudict_test
cars
rm(cars)
cars -> cars1
apply(cars, c(1, 2), function(x){ifelse(x < 10, which(x), "nope")})
apply(cars, c(1, 2), function(x){ifelse(x < 10, which(x) < 10, "nope")})
?seq_along
vec <- vec2 <-  c(5, Inf, 7)
seq_along(vec)
cmudict_test
matrix(data = c(c(1, 2), c(3, 4)), nrow = 2, ncol = 2)
matrix(data = c(c(1, 2), c(3, 4)), nrow = 2, ncol = 2) -> testmatrix
apply(testmatrix, c(1, 2), seq_along)
apply(testmatrix, 1, seq_along)
apply(testmatrix, 2, seq_along)
mapply(testmatrix, 2, seq_along)
?mapply
?sapply
sapply(testmatrix, 2, seq_along)
sapply(testmatrix, seq_along)
lapply(testmatrix, seq_along)
mapply(testmatrix, seq_along)
?vapply
cmudict_test
cmudict_test[1,]
which(right(cmudict_test[1,], 1) == "1")
which(right(cmudict_test[1,], 1) == "0")
colnames(cmudict_test)[which(right(cmudict_test[1,], 1) == "0")]
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/cmudict_downloader.R', echo=TRUE)
# If dict has been successfully downloaded, do some cleanup
if (exists("cmudict_raw") == TRUE) {
message("Formatting dictionary...")
# Remove comment lines
message("Removing comments...")
cmudict_raw %<>% subset(left(., 3) != ";;;")
# Replace spaces with commas, starting w/ double spaces
cmudict_raw %<>% str_replace_all("\\s\\s", ",")
cmudict_raw %<>% str_replace_all("\\s", ",")
# Find out which row is longest by counting commas
# Remove non-word characters from line beginnings
message("Removing non-word characters...")
cmudict_raw %<>% str_replace_all("(?<=^)[^\\w]", "")
longest <- 0
message("Finding longest word...")
for (n in 1:length(cmudict_raw)) {
str_count(cmudict_raw[n], ",") -> fields
if (fields > longest) {
longest <- fields
}
}
# Add version to cmudict_raw
message("Storing version information...")
cmudict_raw <- c(latest_version, cmudict_raw)
# Equalize # of fields (add fields to rows that are shorter than row w/ the highest # of fields)
message("Equalizing row lengths...")
for (n in 1:length(cmudict_raw)) {
# Get diff btw current row and longest row
to_add <- longest - str_count(cmudict_raw[n], ",")
# Add # of commas necessary to match longest row
cmudict_raw[n] <- paste(c(cmudict_raw[n], rep(",", to_add)), collapse = "")
}
# Save as csv
message("Storing and reading as csv...")
write_lines(cmudict_raw,
path = "cmudict_raw.csv",
append = FALSE)
# Make a data.frame from cmudict_raw
cmudict_dld <- read_csv(file = "cmudict_raw.csv",
col_names = c("word", paste("segment", 1:longest, sep = "")),
col_types = cols(.default = col_character()))
# Enrich dictionary with stress information
message("Extracting stress information...")
# Find max number of primary and secondary stresses
message("Counting number of columns needed for stress information...")
max_prim_stress <- 0
max_sec_stress <- 0
for (n in 2:nrow(cmudict_dld)) {
str_count(paste(cmudict_dld[n, (2:longest+1)], collapse = ""), "1") -> prim_stress
str_count(paste(cmudict_dld[n, (2:longest+1)], collapse = ""), "2") -> sec_stress
if (prim_stress > max_prim_stress) {
max_prim_stress <- prim_stress
}
if (sec_stress > max_sec_stress) {
max_sec_stress <- sec_stress
}
}}
cmudict_test
apply(cmudict_test, 1, str_count, "1")
apply(cmudict_test, c(1,2), str_count, "1")
?rapply
?vapply
sapply(cmudict_test, str_count, "1")
lapply(cmudict_test, str_count, "1")
mutate(cmudict_test, n_prim_str = str_count(cmudict_test[2:last_seg_col], "1"))
str_count(cmudict_test[2:last_seg_col], "1")
cmudict_test[2:last_seg_col]
cmudict_test[,2:last_seg_col]
cmudict_test
str_count(cmudict_test, "1")
str_count(cmudict_test[1,], "1")
str_count(paste(cmudict_test[1,], collapse=""), "1")
paste(cmudict_test[1,], collapse="")
paste(cmudict_test[1,2:last_seg_col], collapse="")
paste(cmudict_test, collapse="")
pull(cmudict_test)
apply(cmudict_test, 1, paste, collapse=""))
apply(cmudict_test, 1, paste, collapse="")
subset(cmudict_dld, str_detect(word, "1") = "TRUE")
subset(cmudict_dld, str_detect(word, "1") == "TRUE")
apply(cmudict_test[2:last_seg_col], 1, paste, collapse="")
str_count(apply(cmudict_test[2:last_seg_col], 1, paste, collapse=""), "1")
prim_stress_counts <- str_count(apply(cmudict_dld[2:last_seg_col],
1,
paste,
collapse = ""))
prim_stress_counts
prim_stress_counts <- str_count(apply(cmudict_dld[2:last_seg_col],
1,
paste,
collapse = ""),
"1")
prim_stress_counts
sec_stress_counts <- str_count(apply(cmudict_dld[2:last_seg_col],
1,
paste,
collapse = ""),
"2")
sec_stress_counts
max(prim_stress_counts)
max_prim_stress <- max(prim_stress_counts)
max_sec_stress <- max(sec_stress_counts)
max_prim_stress
1:max_prim_stress
last_seg_col + (1:max_prim_stress)
paste("segment", 1:max_prim_stress, "")
paste("segment", 1:max_prim_stress, sep = "")
paste("primary", 1:max_prim_stress, sep = "")
paste("pr_str", 1:max_prim_stress, sep = "")
paste("prstr", 1:max_prim_stress, sep = "")
cmudict_test$paste("prstr", 1:max_prim_stress, sep = "") <- NA
cmudict_test$eval(paste("prstr", 1:max_prim_stress, sep = "")) <- NA
paste("prstr", 1:max_prim_stress, sep = "")
paste("prstr", 1:max_prim_stress, sep = "") -> blah
cmudict_test$eval(paste("prstr", 1:max_prim_stress, sep = "")) <- NA
cmudict_test$eval(parse(text = paste("prstr", 1:max_prim_stress, sep = ""))) <- NA
cmudict_test$eval(parse(text = blah))
cmudict_test$eval(parse(blah))
cmudict_test[,blah] <- NA
cmudict_test
cmudict_test[,paste("prstr", 1:max_prim_stress, sep = "")] <- NA
cmudict_test[,paste("prstr", 1:max_prim_stress, sep = "")] <- "woo"
cmudict_test$prstr1
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/cmudict_downloader.R', echo=TRUE)
# If dict has been successfully downloaded, do some cleanup
if (exists("cmudict_raw") == TRUE) {
message("Formatting dictionary...")
# Remove comment lines
message("Removing comments...")
cmudict_raw %<>% subset(left(., 3) != ";;;")
# Replace spaces with commas, starting w/ double spaces
cmudict_raw %<>% str_replace_all("\\s\\s", ",")
cmudict_raw %<>% str_replace_all("\\s", ",")
# Find out which row is longest by counting commas
# Remove non-word characters from line beginnings
message("Removing non-word characters...")
cmudict_raw %<>% str_replace_all("(?<=^)[^\\w]", "")
longest <- 0
message("Finding longest word...")
for (n in 1:length(cmudict_raw)) {
str_count(cmudict_raw[n], ",") -> fields
if (fields > longest) {
longest <- fields
}
}
# Add version to cmudict_raw
message("Storing version information...")
cmudict_raw <- c(latest_version, cmudict_raw)
# Equalize # of fields (add fields to rows that are shorter than row w/ the highest # of fields)
message("Equalizing row lengths...")
for (n in 1:length(cmudict_raw)) {
# Get diff btw current row and longest row
to_add <- longest - str_count(cmudict_raw[n], ",")
# Add # of commas necessary to match longest row
cmudict_raw[n] <- paste(c(cmudict_raw[n], rep(",", to_add)), collapse = "")
}
# Save as csv
message("Storing and reading as csv...")
write_lines(cmudict_raw,
path = "cmudict_raw.csv",
append = FALSE)
# Make a data.frame from cmudict_raw
cmudict_dld <- read_csv(file = "cmudict_raw.csv",
col_names = c("word", paste("segment", 1:longest, sep = "")),
col_types = cols(.default = col_character()))
# Enrich dictionary with stress information
message("Extracting stress information...")
# Find max number of primary and secondary stresses
message("Counting number of columns needed for stress information...")
# Count the number of primary and secondary stresses in each word
prim_stress_counts <- str_count(apply(cmudict_dld[2:last_seg_col],
1,
paste,
collapse = ""),
"1")
sec_stress_counts <- str_count(apply(cmudict_dld[2:last_seg_col],
1,
paste,
collapse = ""),
"2")}
cmudict_dld
source('C:/Users/jakew/OneDrive/Documents/School/UCSC Grad school/Other projects/Syllable parser/R implementation/cmudict_downloader.R', echo=TRUE)
# If dict has been successfully downloaded, do some cleanup
if (exists("cmudict_raw") == TRUE) {
message("Formatting dictionary...")
# Remove comment lines
message("Removing comments...")
cmudict_raw %<>% subset(left(., 3) != ";;;")
# Replace spaces with commas, starting w/ double spaces
cmudict_raw %<>% str_replace_all("\\s\\s", ",")
cmudict_raw %<>% str_replace_all("\\s", ",")
# Find out which row is longest by counting commas
# Remove non-word characters from line beginnings
message("Removing non-word characters...")
cmudict_raw %<>% str_replace_all("(?<=^)[^\\w]", "")
longest <- 0
message("Finding longest word...")
for (n in 1:length(cmudict_raw)) {
str_count(cmudict_raw[n], ",") -> fields
if (fields > longest) {
longest <- fields
}
}
# Add version to cmudict_raw
message("Storing version information...")
cmudict_raw <- c(latest_version, cmudict_raw)
# Equalize # of fields (add fields to rows that are shorter than row w/ the highest # of fields)
message("Equalizing row lengths...")
for (n in 1:length(cmudict_raw)) {
# Get diff btw current row and longest row
to_add <- longest - str_count(cmudict_raw[n], ",")
# Add # of commas necessary to match longest row
cmudict_raw[n] <- paste(c(cmudict_raw[n], rep(",", to_add)), collapse = "")
}
# Save as csv
message("Storing and reading as csv...")
write_lines(cmudict_raw,
path = "cmudict_raw.csv",
append = FALSE)
# Make a data.frame from cmudict_raw
cmudict_dld <- read_csv(file = "cmudict_raw.csv",
col_names = c("word", paste("segment", 1:longest, sep = "")),
col_types = cols(.default = col_character()))
# Enrich dictionary with stress information
message("Extracting stress information...")
# Find max number of primary and secondary stresses
message("Counting number of columns needed for stress information...")
# Count the number of primary and secondary stresses in each word
prim_stress_counts <- str_count(apply(cmudict_dld[2:last_seg_col],
1,
paste,
collapse = ""),
"1")
sec_stress_counts <- str_count(apply(cmudict_dld[2:last_seg_col],
1,
paste,
collapse = ""),
"2")
# Get the highest number for each
max_prim_stress <- max(prim_stress_counts)
max_sec_stress <- max(sec_stress_counts)
# Add appropriate # of cols for each kind of stress
cmudict_dld[,paste("prstr", 1:max_prim_stress, sep = "_")] <- NA
cmudict_dld[,paste("secstr", 1:max_sec_stress, sep = "_")] <- NA}
cmudict_dld
apply(cmudict_test, 1, paste, collapse = "")
apply(cmudict_test[2:], 1, paste, collapse = "")
apply(cmudict_test[2:last_seg_col], 1, paste, collapse = "")
apply(cmudict_test[2:last_seg_col], 1, function(x){which(x) == "1"})
?rapply
which(right(cmudict_test[1,], 1) == "0")
which(right(cmudict_test[1,], 1) == "1")
which(right(cmudict_test, 1) == "1")
apply(cmudict_test, 1, function(x){which(right(x, 1) == "1"})
apply(cmudict_test, 1, function(x) = pull(x))
apply(cmudict_test, 1, function(x) {pull(x)})
apply(cmudict_test, 1, function(x) {as.vector(x)})
lapply(cmudict_test, function(x){which(left(x, 1)) == "1"})
which(left(cmudict_test), 1) == 1
which(left(cmudict_test[1,]), 1) == 1
which(left(cmudict_test[,1]), 1) == 1
cmudict_test[,1]
cmudict_test[1,]
which(left(cmudict_test[1,], 1)) == 1
which(left(cmudict_test[1,], 1) == 1)
which(left(cmudict_test[1,], 1) == "1")
?which
which(left(cmudict_test[1,]) == "1")
cmudict_test[1,]
pull(cmudict_test[1,])
cmudict_test[1,] %>% as.vector()
which(right(cmudict_test[1,], 1) == "1")
which(right(cmudict_test[1,], 1) == "1")
apply(cmudict_test, 1, function(x){which(right(x[1,], 1) == "1")})
apply(cmudict_test, 1, function(x){which(right(x, 1) == "1")})
lapply(cmudict_test, 1, function(x){which(right(x, 1) == "1")})
apply(cmudict_test, 1, function(x){which(right(x[1,], 1) == "1")})
apply(cmudict_test, 1, function(x){which(right(x[1,], 1) == "1")})
apply(cmudict_test, 1, function(x){which(right(x, 1) == "1")})
apply(cmudict_test, 1, function(x){which(right(x, 1) == "1")}) %>% unlist
apply(cmudict_test, 1, function(x){colnames(cmudict_test)[which(right(x, 1) == "1")]})
cmudict_test[17,]
apply(cmudict_test, 1, function(x){colnames(cmudict_test)[which(right(x, 1) == "1")]})
apply(cmudict_test, 1, function(x){colnames(cmudict_test)[which(right(x, 1) == "1")]}) %>% as.data.frame
apply(cmudict_test, 1, function(x){colnames(cmudict_test)[which(right(x, 1) == "1")]}) %>% as.matrix
apply(cmudict_test, 1, function(x){colnames(cmudict_test)[which(right(x, 1) == "1")]})
apply(cmudict_test, 1, function(x){colnames(cmudict_test)[which(right(x, 1) == "1")]})[1]
apply(cmudict_test, 1, function(x){colnames(cmudict_test)[which(right(x, 1) == "1")]})[2]
nrow(cmudict_test)
