"0","# Parse by indexing linear string, using sonority"
"0","# Parse stepwise by nucleus, onset, and coda; identifying dipththongs as a single nucleus"
"0","syllabify_v0.2 <- function(input, diphthong_list, onset_list) {"
"0","  "
"0","  # Required packages"
"0","  require(stringr)"
"0","  "
"0","  # If diphthongs aren't specified, set it to American English diphthongs"
"0","  if (missing(diphthong_list)) {"
"0","    diphthong_list <- c(""aɪ"", ""aʊ"", ""eɪ"", ""oʊ"", ""ɔɪ"")"
"0","    #warning(""No diphthongs provided. Using Standard American English diphthongs."")"
"0","  }"
"0",""
"0","  # If licit onsets not supplied, use this list"
"0","  if (missing(onset_list)) {"
"0","    onset_list <- c(""ʃɹ"", ""θɹ"", ""bɹ"", ""bj"", ""bl"", ""dɹ"", ""dw"", ""fɹ"", ""fj"", ""fl"", ""gɹ"", ""gl"", ""gw"", ""hj"", ""hw"", ""kɹ"", ""kj"", ""kl"", ""kw"", ""mj"", ""pɹ"", ""pj"", ""pl"", ""sk"", ""sl"", ""sm"", ""sn"", ""sp"", ""st"", ""sw"", ""tɹ"", ""tw"")"
"0","    # Removed: ʃl, ʃm, ʃn, ʃw, bw (two bilabials), dj, gj, sv, ts, "
"0","  }"
"0","  "
"0","  # Make a df to store syllabification info"
"0","  syllabification <- data.frame(NA)"
"0","  "
"0","  # Assign colnames"
"0","  colnames(syllabification) <- ""input"""
"0","  "
"0","  # Give the df the unicode_df class so it's printed correctly"
"0","  class(syllabification) <- c(""unicode_df"","
"0","                              ""data.frame"")"
"0","  "
"0","  # Syllabify each word in the input, adding its information to each row"
"0","  for (word in 1:length(input)) {"
"0","    # Add the word to the df"
"0","    syllabification[word, 1] <- input[word]"
"0","    "
"0","    # Index ea segment by splitting word into component chars & associating ea w/ a # corresponding to its string-linear position"
"0","    split_word <- unlist(strsplit(as.character(input[word]), split = """"))"
"0","    char_index <- as.data.frame(as.matrix(split_word))"
"0","    class(char_index) <- c(""unicode_df"","
"0","                           ""data.frame"")"
"0","    colnames(char_index)[1] <- ""segment"""
"0","    char_index[,""position""] <- 1:length(split_word)"
"0","    char_index[,""sonority""] <- sonority(split_word)"
"0","    char_index[,""parsed""] <- FALSE"
"0","    char_index[,""syllable""] <- 0"
"0","    "
"0","    ### Determine syllable nuclei ###"
"0","    # Extract vowels"
"0","    vowels <- subset(char_index,"
"0","                     cvify(segment) == ""V"")"
"0","    "
"0","    # Get adjacent vowels (if there is more than one vowel in the word) & determine if they're diphthongs"
"0","    if (length(vowels$segment) > 1){"
"0","      ## Make a df to store each sequence of two vowels"
"0","      vowel_bigrams <- as.data.frame(matrix(ncol = 2))"
"0","      ## Set x to 1; each time the loop runs it will be increased by one so that the next bigram can be extracted"
"0","      x <- 1"
"0","      ## Get positions in linear string of original word of bigrams of extracted vowels"
"0","      for (vowel in 1:nrow(vowels)) {"
"0","        # If we didn't just parse the last vowel (if x is not equal to the number of vowels in the word), ..."
"0","        if (x != nrow(vowels)) {"
"0","          # ...then get the positions of those vowels and put in the vowel_bigram df"
"0","          vowel_bigrams[vowel,] <- vowels[x:(x+1),""position""]"
"0","          x <- x+1"
"0","        }"
"0","      }"
"0","      ## Get the diffs btw the pos'ns in the linear str to see which vowels were adjacent to each other in the original word"
"0","      vowel_bigrams$diff <- vowel_bigrams[,2] - vowel_bigrams[,1]"
"0","      ## If any vowels have a position difference of 1 (were actually adjacent to each other in the original string), subset only to them"
"0","      if (1 %in% vowel_bigrams$diff){"
"0","        ## Subset to originally adjacent vowels"
"0","        adjacent_vowels <- subset(vowel_bigrams,"
"0","                                  diff == 1)"
"0","		    class(adjacent_vowels) <- c(""unicode_df"","
"0","		                                ""data.frame"")"
"0","        ## Extract the adjacent vowels using their positions & paste them together in a new column"
"0","        for (pair in 1:nrow(adjacent_vowels)) {"
"0","          adjacent_vowels[pair,""bigram""] <- paste(as.character(char_index[,""segment""][adjacent_vowels[pair,1]]),"
"0","                                                  as.character(char_index[,""segment""][adjacent_vowels[pair,2]]),"
"0","                                                  sep = """")"
"0","        }"
"0","        ## See if any of these bigrams match the known diphthongs & indicate in adjacent_vowels w/ TRUE or FALSE"
"0","        for (bigram in 1:nrow(adjacent_vowels)) {"
"0","          # If the bigram is in the list of diphthongs, mark it as TRUE"
"0","          if(adjacent_vowels[bigram,""bigram""] %in% diphthong_list){"
"0","            adjacent_vowels[bigram,""diphthong""] <- TRUE"
"0","          } else {"
"0","            # Otherwise, mark it as false"
"0","            adjacent_vowels[bigram,""diphthong""] <- FALSE"
"0","          }"
"0","        }"
"0","        # Save the bigrams that are recognized diphthongs if there are any"
"0","        if (TRUE %in% adjacent_vowels$diphthong){"
"0","          diphthongs <- droplevels(subset(adjacent_vowels,"
"0","                                          diphthong == TRUE))"
"0","		      class(diphthongs) <- c(""unicode_df"","
"0","		                             ""data.frame"")"
"0","        }"
"0","      }"
"0","    }"
"0","    "
"0","    # Add column to vowel df that says whether the vowel is part of a diphthong (TRUE) or monophthong (FALSE), and if it is part of a diphthong, which diphthong it's a part of (by which row in the diphthongs df it's in)"
"0","    for (vowel in 1:nrow(vowels)) {"
"0","      if (exists(""diphthongs"")) {"
"0","        if (vowels$position[vowel] %in% as.character(as.matrix(diphthongs[,1:2]))) {"
"0","        vowels[vowel,""in.diphthong""] <- TRUE"
"0","        vowels[vowel,""which.diphthong""] <- row(diphthongs[,1:2])[which(diphthongs[,1:2] == vowels$position[vowel])]"
"0","        } else {"
"0","          vowels[vowel,""in.diphthong""] <- FALSE"
"0","          # If the vowel isn't part of a diphthong, set ""which.diphthong"" to 0. Anything that's an actual diphthong will never be assigned zero since row numbers (in the diphthongs df) start w/ 1. Needs to be 0 b/c otherwise it's NA, in which case an error is returned when testing if two vowel characters are part of the same diphthong."
"0","          vowels[vowel,""which.diphthong""] <- 0"
"0","        }"
"0","      } else {"
"0","        vowels[vowel,""in.diphthong""] <- FALSE"
"0","        # If the vowel isn't part of a diphthong, set ""which.diphthong"" to 0. Anything that's an actual diphthong will never be assigned zero since row numbers (in the diphthongs df) start w/ 1. Needs to be 0 b/c otherwise it's NA, in which case an error is returned when testing if two vowel characters are part of the same diphthong."
"0","        vowels[vowel,""which.diphthong""] <- 0"
"0","      }"
"0","    }"
"0","    "
"0","    # We now have enough information to say which vowel segments are associated w/ which syllables"
"0","    # Cycle through the vowel df and create a vector for the syllable nuclei in this word"
"0","    nuclei <- NA"
"0","    x <- 1"
"0","    for (vowel in 1:nrow(vowels)) {"
"0","      # If the vowel is not part of a diphthong, add it to the list of nuclei"
"0","      if (vowels[vowel,""in.diphthong""] == FALSE) {"
"0","        nuclei[x] <- as.character(vowels[vowel,""segment""])"
"0","        # Change parsed status to TRUE"
"0","        char_index[vowels[vowel,""position""],]$parsed <- TRUE"
"0","        # Indicate which syllable this vowel was parsed into"
"0","        char_index[vowels[vowel,""position""],]$syllable <- paste(c(""\u03C3."", x),"
"0","                                                                collapse = """")"
"0","        # Add one to the syllable counter"
"0","        x <- x+1"
"0","      } else {"
"0","        # If we're not at the last vowel in vowels and the vowel and the following vowel are part of a diphthong together, paste them together as the next nucleus"
"0","        if (vowel != nrow(vowels)) {"
"0","          if (vowels[vowel,""which.diphthong""] > 0 & vowels[vowel,""which.diphthong""] == vowels[vowel+1,""which.diphthong""]) {"
"0","          nuclei[x] <- paste(as.character(vowels[vowel:(vowel+1),""segment""]),"
"0","                             collapse = """")"
"0","          # Change parsed status for both vowels to TRUE"
"0","          char_index[vowels[vowel,""position""],]$parsed <- TRUE"
"0","          char_index[vowels[vowel,""position""]+1,]$parsed <- TRUE"
"0","          # Indicate which syllable this vowel and the following vowel was parsed into"
"0","          char_index[vowels[vowel,""position""],]$syllable <- paste(c(""\u03C3."", x),"
"0","                                                                  collapse = """")"
"0","          char_index[vowels[vowel,""position""]+1,]$syllable <- paste(c(""\u03C3."", x),"
"0","                                                                    collapse = """")"
"0","          x <- x+1"
"0","        }"
"0","        }"
"0","      }"
"0","    }"
"0","    "
"0","    # Add nuclei to syllabification table for current word"
"0","    for (nucleus in 1:length(nuclei)) {"
"0","      syllabification[word,paste(c(""\u03C3"", nucleus),"
"0","                                 collapse = ""."")] <- as.character(nuclei[nucleus])"
"0","    }"
"0","    "
"0","    # Remove vowel-related objects (IMPORTANT; this can screw up the next word if more than one word is supplied to the function)"
"0","    if (exists(""vowel_bigrams"")) {"
"0","      rm(vowel_bigrams)"
"0","    }"
"0","    if (exists(""adjacent_vowels"")) {"
"0","      rm(adjacent_vowels)"
"0","    }"
"0","    if (exists(""diphthongs"")){"
"0","      rm(diphthongs)"
"0","    }"
"0","    "
"0","    message(""Step 1: Identify syllable nuclei: "","
"0","            paste(syllabification[,2:ncol(syllabification)],"
"0","                  collapse = "", ""))"
"0","    "
"0","    "
"0","    "
"0","    ### Parse onsets ###"
"0","    # For each unparsed consonant in the character index, starting from the end of the word, ..."
"0","    for (consonant in rev(subset(char_index, parsed == FALSE)$position)) {"
"0","      # If the consonant is preceding the first vowel, parse it into the first syllable"
"0","      if (char_index[consonant,""position""] < vowels[1,""position""]) {"
"0","        syllabification[word,""\u03C3.1""] <- paste(c(as.character((char_index[,""segment""])[consonant]),"
"0","                                                    syllabification[word,""\u03C3.1""]),"
"0","                                                  collapse = """")"
"0","        # Indicate that it is now parsed and that it went into the first syllable"
"0","        char_index[consonant,""parsed""] <- TRUE"
"0","        char_index[consonant,""syllable""] <- ""\u03C3.1"""
"0","      } else {"
"0","        # Otherwise, if the position of the unparsed consonant immediately precedes a vowel, parse it with that vowel"
"0","        if ((char_index[consonant,""position""]+1) %in% vowels$position) {"
"0","          syllabification[word,char_index[consonant+1,""syllable""]] <- paste(c(as.character(char_index[consonant,""segment""]),"
"0","                                                                              syllabification[word,char_index[consonant+1,""syllable""]]),"
"0","                                                                            collapse = """")"
"0","          # Indicate that it is now parsed and that it went into the syllable of the vowel that follows it"
"0","          char_index[consonant,""parsed""] <- TRUE"
"0","          char_index[consonant,""syllable""] <- char_index[consonant+1, ""syllable""]"
"0","        } else {"
"0","          # Otherwise, if the position of the unparsed consonant does NOT immediately precede the end of the word, AND immediately precedes another consonant, check if the string formed by pasting those two consonants together is in the list of licit onsets"
"0","          if (is.na(as.character(char_index[consonant+1, ""segment""])) == FALSE){"
"0","            if (cvify(as.character(char_index[consonant+1,""segment""])) == ""C"") {"
"0","              # If those two characters pasted together is in the list of licit onsets, then parse the current consonant into the syllable of the following consonant"
"0","              if (paste(c(as.character(char_index[consonant, ""segment""]),"
"0","                          as.character(char_index[consonant+1, ""segment""])),"
"0","                        collapse = """") %in% onset_list) {"
"0","                syllabification[word,char_index[consonant+1,""syllable""]] <- paste(c(as.character(char_index[consonant,""segment""]),"
"0","                                                                                    syllabification[word,char_index[consonant+1,""syllable""]]),"
"0","                                                                                  collapse = """")"
"0","                # And mark that segment's parsed status as TRUE and indicate which syllable it was parsed into"
"0","                char_index[consonant,""parsed""] <- TRUE"
"0","                char_index[consonant,""syllable""] <- char_index[consonant+1, ""syllable""]"
"0","              }"
"0","            }"
"0","          }"
"0","        }"
"0","      }"
"0","    }"
"0","    "
"0","    message(""Step 2: Identify syllable onsets: "","
"0","            paste(syllabification[,2:ncol(syllabification)],"
"0","                  collapse = "", ""))"
"0","    "
"0","    ### Parse codas ###"
"0","    # For each unparsed consonant in the character index, starting from the beginning of the word, ..."
"0","    for (consonant in subset(char_index, parsed == FALSE)$position) {"
"0","      # Parse that consonant into the coda of the syllable into which the preceding segment was parsed"
"0","      syllabification[word, char_index[consonant-1,""syllable""]] <- paste(c(syllabification[word, char_index[consonant-1,""syllable""]],"
"0","                                                                           as.character(char_index[consonant,""segment""])),"
"0","                                                                         collapse = """")"
"0","      # And mark that segment's parsed status as TRUE and indicate which syllable it was parsed into"
"0","      char_index[consonant, ""parsed""] <- TRUE"
"0","      char_index[consonant, ""syllable""] <- char_index[consonant-1, ""syllable""]"
"0","    }"
"0","    "
"0","    message(""Step 3: Identify syllable codas: "","
"0","            paste(syllabification[,2:ncol(syllabification)],"
"0","                  collapse = "", ""))"
"0","  }"
"0","  # For each column in syllabification tbl, create collapsed version of syllabified word, using periods to separate syllables"
"0","#  for (word in nrow(syllabification)) {"
"0","#    for (syllable in )"
"0","#  }"
"0","  return(syllabification)"
"0","}"
